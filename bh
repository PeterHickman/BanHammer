#!/usr/bin/env ruby

require 'fileutils'

class Whitelist
  def initialize(filename)
    @filename = filename

    @addresses = []

    load
  end

  def include?(address)
    @addresses.include?(address)
  end

  def each(&block)
    @addresses.each(&block)
  end

  private

  def load
    path = File.dirname(@filename)

    FileUtils.mkdir_p(path) unless File.directory?(path)

    if File.exist?(@filename)
      File.open(@filename, 'r').each do |line|
        @addresses << line.chomp
      end
    else
      FileUtils.touch(@filename)
    end
  end
end

class Blacklist
  def initialize(filename)
    @filename = filename

    @addresses = {}
    @changed = false

    load
  end

  def []=(key, value)
    return if key.nil?
    @addresses[key] = value
    @changed = true
  end

  def each(&block)
    @addresses.each(&block)
  end

  def key?(key)
    @addresses.key?(key)
  end

  def delete(key)
    @addresses.delete(key)
    @changed = true
  end

  def save
    return unless @changed

    f = File.open(@filename, 'w')
    @addresses.each do |blacklisted_ip_address, ts|
      f.puts "#{blacklisted_ip_address} #{ts}"
    end
    f.close

    @changed = false
  end

  private

  def load
    path = File.dirname(@filename)

    FileUtils.mkdir_p(path) unless File.directory?(path)

    if File.exist?(@filename)
      File.open(@filename, 'r').each do |line|
        address, timestamp = line.chomp.split(/\s+/)
        @addresses[address] = timestamp
      end
    else
      FileUtils.touch(@filename)
    end
  end
end

class Existing
  def initialize
    @addresses = {}

    load
  end

  def key?(key)
    @addresses.key?(key)
  end

  def [](key)
    @addresses[key]
  end

  def <<(key)
    return if key.nil?
    return if @addresses.key?(key)
    UFW.add(key)
    load
  end

  private

  def load
    @addresses = UFW.load
  end
end

class ImportAuth
  def self.import(filename)
    ##
    # Filter the auth.log file and find out who has been grinding
    # at the ssh service and ban them. Only actually ban them when
    # they hit > 100 attempts
    ##

    a = Hash.new(0)

    File.open(filename, 'r').each do |line|
      next unless line.include?('sshd[')

      if line.include?('not allowed because none')
        a[strip_address(line)] += 1
      elsif line.include?(' Invalid user ')
        a[strip_address(line)] += 1
      end
    end

    addresses = []

    a.each do |ip_address, count|
      next if count < 100
      next if ip_address.nil?
      addresses << ip_address
    end

    addresses
  end
end

class ImportUFW
  def self.import(filename)
    ##
    # Filters the ufw.log file and gets a list of addresses that
    # were blocked. If any of the addresses are already in the
    # blacklist then their timestamp is bumped
    ##

    a = Hash.new(0)

    File.open(filename, 'r').each do |line|
      # We are only looking for addresses that ufw has blocked ...
      next unless line.include?('UFW BLOCK')

      # ... and they must be inbound only
      next unless line.include?('OUT= ')

      address = line.split(/\s+/).select { |x| x.index('SRC=') == 0 }

      next unless address.any?

      address = address.first.delete('SRC=')

      a[address] += 1
    end

    a
  end
end

class UFW
  def self.delete(number)
    `echo y | ufw delete #{number}`
  end

  def self.add(ip_address)
    `ufw insert 1 deny from #{ip_address}`
  end

  def self.load
    addresses = {}

    x = `ufw status numbered`

    x.split("\n").each do |line|
      next unless line.include?('DENY IN')

      line = line.delete('[').delete(']').strip
      y = line.split(/\s+/)
      addresses[y.last] = y.first
    end

    addresses
  end
end

WHITELIST = '/etc/ban_hammer/whitelist'.freeze
BLACKLIST = '/etc/ban_hammer/blacklist'.freeze

RE_IP_ADDRESS = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/
RE_FROM = / from ([^ ]+)\s+/

def save_blacklist(ip_address = nil)
  $existing << ip_address
  $blacklist[ip_address] = Time.now.to_i
  $blacklist.save
end

def strip_address(line)
  begin
    m = RE_FROM.match(line)
    ip_address = m[1]
    return nil unless ip_address =~ RE_IP_ADDRESS
    return ip_address
  rescue
    return nil
  end
end

def get_address(error_message)
  if ARGV[0].nil?
    puts error_message
    exit(1)
  end

  ARGV.shift
end

def get_filename(error_message)
  if ARGV[0].nil?
    puts error_message
    exit(1)
  end

  filename = ARGV.shift.downcase

  unless File.exist?(filename)
    puts "[#{filename}] not found"
    exit(1)
  end

  filename
end

def command_update
  missing = 0

  puts 'Checking that ufw is up to date'
  $blacklist.each do |ip_address, _|
    next if $existing.key?(ip_address)

    command_add(ip_address)
    missing += 1
  end
  puts "There are #{$blacklist.size} banned addresses, #{missing} were missing"
end

def command_show
  puts "Whitelist (#{WHITELIST})"
  $whitelist.each do |ip_address|
    puts "- #{ip_address}"
  end
  puts
  puts "Blacklist (#{BLACKLIST})"
  $blacklist.each do |ip_address, _|
    puts "- #{ip_address}"
  end
  puts
end

def command_add(ip_address)
  if $whitelist.include?(ip_address)
    puts "#{ip_address} is in the whitelist"
  elsif $blacklist.key?(ip_address)
    puts "#{ip_address} is already blacklisted. Bumping timestamp"
    save_blacklist(ip_address)
  else
    puts "#{ip_address} added to blacklist"
    save_blacklist(ip_address)
  end
end

def command_remove(ip_address)
  found = false

  if $blacklist.key?(ip_address)
    $blacklist.delete(ip_address)
    save_blacklist
    found = true
  end

  if $existing.key?(ip_address)
    number = $existing[ip_address]
    UFW.delete(number)
    found = true
  end
  
  if found
    puts "#{ip_address} removed from blacklist"
  else
    puts "#{ip_address} is not in the blacklist"
  end
end

def command_import_ufw(filename)
  puts "Scanning ufw.log #{filename} for repeat offenders"

  a = ImportUFW.import(filename)

  a.each do |address, _|
    next unless $blacklist.key?(address)
    $blacklist[address] = Time.now.to_i
    puts "#{address} found. Bumping timestamp"
  end
end

def command_import_auth(filename)
  puts "Filtering auth.log #{filename} for addresses to ban"

  a = ImportAuth.import(filename)

  a.each do |ip_address, count|
    command_add(ip_address)
  end
end

$whitelist = Whitelist.new(WHITELIST)
$blacklist = Blacklist.new(BLACKLIST)
$existing = Existing.new

unless ARGV[0]
  puts 'No command given'
  exit(1)
end

cmd = ARGV.shift.downcase

case cmd
when 'update'
  command_update
when 'show'
  command_show
when 'add'
  ip_address = get_address('No address given to ban')

  command_add(ip_address)
when 'remove'
  ip_address = get_address('No address given to remove')

  command_remove(ip_address)
when 'import'
  if ARGV[0].nil?
    puts "No subcommand given for 'import', should be 'ufw' or 'auth'"
    exit(1)
  end

  sub_command = ARGV.shift.downcase

  filename = get_filename("No file given for 'import #{sub_command}'")

  case sub_command
  when 'ufw'
    command_import_ufw(filename)
  when 'auth'
    command_import_auth(filename)
  else
    puts "Unrecognised subcommand [#{sub_command}] for 'import'"
  end
else
  puts "Unknown command [#{cmd}]"
end
